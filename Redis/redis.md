![知识图谱](/Redis/知识图谱.png)
---

1. Redis
    - 一种使用C语言编写的、开源的、高性能非关系型(NoSQL)的键值对数据库.
    - 可基于内存亦可持久化的日志型、Key-Value数据库.
    - 优点:
        - 读写性能优异: 读11w次/秒、写8.1w次/秒.
        - 支持数据持久化: AOF和RDS.
        - 支持事务, Redis所有操作都是原子性的,  
          也支持一组操作合并后的原子性执行.
        - 数据结构丰富.
        - 支持主从复制、读写分离.
    - 缺点:
        - 数据库容量受到物理内存的限制, 不能用作海量数据的高性能读写.
        - 当修改Redis的数据之后需要将持久化到硬盘的数据重新加入到内容中,  
          时间比较久, 这个时候Redis是无法正常运行的.
        - 不具备自动容错和恢复功能, 主机从机的宕机都会导致部分读写请求失败,  
          需要等待机器重启或者手动切换前端的IP才能恢复.
        - 较难支持在线扩容, 在集群容量达到上限时在线扩容会变得很复杂.

---

2. 缓存问题
    - 缓存击穿
        - 当从缓存中查询不到我们需要的数据就要去数据库中查询.
        - 解决方案:
            - 后台设置定时任务, 主动的去更新缓存数据.
            - 分级缓存:
                - 设置两层缓存保护层, 1级缓存失效时间短, 2级缓存失效时间长.
                - 请求过来优先从1级缓存中去查找,  
                  如果在1级缓存中没有找到相应数据, 则对该线程进行加锁,  
                  这个线程再从数据库中取到数据, 更新至1级和2级缓存;  
                  其他线程则直接从2级线程中获取.
            - 提供一个拦截机制, 内部维护一系列合法的key值.  
              当请求的key不合法时, 直接返回.
    - 缓存雪崩
        - 缓存由于某些原因整体crash掉了, 导致大量请求到达后端数据库,  
          从而导致数据库崩溃, 整个系统崩溃, 发生灾难.
        - 解决方案:
            - 给缓存加上一定区间内的随机生效时间, 不同的key设置不同的失效时间,  
              避免同一时间集体失效.
            - 二级缓存, 原始缓存失效时从拷贝缓存中读取数据.
            - 利用加锁或者队列方式避免过多请求同时对服务器进行读写操作.

---

3. Redis为什么这么快:
    - 完全基于内存.
    - 数据结构简单.
    - 采用单线程, 避免了不必要的上下文切换和竞争条件,  
      也不存在多进程或者多线程导致的切换而消耗CPU, 不用去考虑各种锁的问题,  
      不存在加锁释放锁操作, 没有因为可能出现死锁而导致的性能消耗.
    - 使用多路I/O复用模型, 非阻塞IO.
    - 使用底层模型不同, 自己构建了VM机制, 数据存储进行了压缩优化.

---

4. Redis线程模型 -- 单线程模型
    - 基于Reactor模式的网络事件处理器(文件事件处理器):
        - 多个套接字
        - O多路复用程序
        - 文件事件分派器
        - 事件处理器
    - 文件事件处理器使用I/O多路复用程序来同时监听多个套接字,  
      并根据套接字目前执行的任务来为套接字关联不同的事件处理器.
    - 当被监听的套接字准备好执行连接应答, 读取, 写入, 关闭等操作时,  
      与操作相对应的文件事件就会产生, 这时文件事件处理器  
      就会调用套接字之前关联好的事件处理器来处理这些事件.
      
---

5. 事务
    - 一致性、隔离性
    
---

6. 分区
    - 分区可以让Redis管理更大的内存, Redis将可以使用所有机器的内存.
    - 提高计算能力, 带宽
    - 客户端分, 代理分区, 查询路由
    - 缺点:
        - 涉及多个key的操作通常不会被支持, 如: 并集.
        - 同时操作多个key, 则不能使用Redis事务.
        - 分区使用的粒度是key, 不能使用一个非常长的排序key存储一个数据集.
        - 当使用分区的时候, 数据处理会非常复杂, 如: 要到各个节点收集备份文件.
        - 分区时动态扩容或缩容可能非常复杂.
    
---

7. 布隆过滤器
    - 引入了k(k>1)k(k>1)个相互独立的哈希函数, 保证在给定的空间和误判率下,  
      完成元素判重的过程.

---

8. 主从复制 - Copy-on-Write(写时复制)
    - 2.8之前: 同步sync和指令传播
    - 2.8之后: PSYNC
        - 完整重同步
        - 部分重同步: 复制偏移量, 复制积压缓冲区
    
---

9. pipeline: 减少网络IO