![知识图谱](/Redis/知识图谱.png)
---
1. Redis
    - 一种使用C语言编写的、开源的、高性能非关系型(NoSQL)的键值对数据库.
    - 可基于内存亦可持久化的日志型、Key-Value数据库.  
    - 优点:  
        - 读写性能优异: 读11w次/秒、写8.1w次/秒.
        - 支持数据持久化: AOF和RDS.
        - 支持事务, Redis所有操作都是原子性的,  
          也支持一组操作合并后的原子性执行.
        - 数据结构丰富.
        - 支持主从复制、读写分离.
    - 缺点:
        - 数据库容量受到物理内存的限制, 不能用作海量数据的高性能读写.
        - 当修改Redis的数据之后需要将持久化到硬盘的数据重新加入到内容中,  
          时间比较久, 这个时候Redis是无法正常运行的.
        - 不具备自动容错和恢复功能, 主机从机的宕机都会导致部分读写请求失败,  
          需要等待机器重启或者手动切换前端的IP才能恢复.
        - 较难支持在线扩容, 在集群容量达到上限时在线扩容会变得很复杂.  
---
2. 缓存问题
    - 缓存击穿
        - 当从缓存中查询不到我们需要的数据就要去数据库中查询.
        - 解决方案:
            - 后台设置定时任务, 主动的去更新缓存数据.
            - 分级缓存:
                - 设置两层缓存保护层, 1级缓存失效时间短, 2级缓存失效时间长.
                - 请求过来优先从1级缓存中去查找,  
                  如果在1级缓存中没有找到相应数据, 则对该线程进行加锁,  
                  这个线程再从数据库中取到数据, 更新至1级和2级缓存;  
                  其他线程则直接从2级线程中获取.
            - 提供一个拦截机制, 内部维护一系列合法的key值.  
              当请求的key不合法时, 直接返回.
    - 缓存雪崩
        - 缓存由于某些原因整体crash掉了, 导致大量请求到达后端数据库,  
          从而导致数据库崩溃, 整个系统崩溃, 发生灾难.
        - 解决方案:
            - 给缓存加上一定区间内的随机生效时间, 不同的key设置不同的失效时间,  
              避免同一时间集体失效.
            - 二级缓存, 原始缓存失效时从拷贝缓存中读取数据.
            - 利用加锁或者队列方式避免过多请求同时对服务器进行读写操作.
---
3. Redis为什么这么快:
    - 完全基于内存.
    - 数据结构简单.
    - 采用单线程, 避免了不必要的上下文切换和竞争条件,  
      也不存在多进程或者多线程导致的切换而消耗CPU, 不用去考虑各种锁的问题,  
      不存在加锁释放锁操作, 没有因为可能出现死锁而导致的性能消耗.
    - 使用多路I/O复用模型, 非阻塞IO.
    - 使用底层模型不同, 自己构建了VM机制.
