### 三次握手

![三次握手](/NetWork/三次握手.png)

### 四次挥手

![四次挥手](/NetWork/四次挥手.png)

### 如果三次握手的时候每次握手信息对方没有收到会怎么样

1. 第一次握手服务器未接收到客户端请求建立连接的数据包:
    - 服务器不会进行任何相应的动作.
    - 客户端由于在一段时间内没有收到服务器发来的确认报文, 等待一段时间后重新发送SYN同步报文.
    - 直到发送次数超过最大重传次数限制后, 建立连接的系统调用会返回-1.

2. 第二次握手客户端未接收到服务器回应的ACK报文:
    - 客户端会采取第一次握手失败时的动作.
    - 服务器端此时将阻塞在accept()系统调用处等待client再次发送ACK报文.

3. 第三次握手服务器未接收到客户端发送过来的ACK报文.
    - 服务端会采取类似于客户端的超时重传机制, 重传次数超过限制后仍然没有回应, 则accept()系统调用返回-1, 服务器端连接建立失败.
    - 客户端认为自己已经连接成功了, 开始向服务器端发送数据, 但是服务器端的accept()系统调用已返回, 此时没有在监听状态.
    - 服务器端接收到来自客户端发送来的数据时会发送RST报文给客户端, 消除客户端单方面建立连接的状态.

### 为什么要进行三次握手？两次握手可以吗？

1. 三次握手保证两点:
    - 保证双方都是双工通信:
        - 第一次握手, 服务端确定客户端的发送正常.
        - 第二次握手, 客户端确认服务端的收发正常.
        - 第三次握手, 服务端确定客服端接收正常.
    - 如果只有第二次握手, 服务端发给客服端的包丢了之后, 服务端就直接建立了连接, 然后一直傻等不会释放, 造成阻塞.

### 第 2 次握手传回了 ACK, 为什么还要传回 SYN

> ACK是为了告诉客户端发来的数据已经接收无误, 而传回SYN是为了告诉客户端, 服务端收到的消息确实是客户端发送的消息.

### 为什么要四次挥手？

> FIN释放连接报文和ACK确认接收报文是分别在两次握手中传输的.
> (TCP是全双工, 两个方向的连接需要单独关闭)

### CLOSE-WAIT 和 TIME-WAIT 的状态和意义

1. CLOSE-WAIT: 保证服务器在关闭连接之前将待发送的数据发送完成.
2. TIME-WAIT:
    - 防止客户端接在相同的端口立即建立新的连接, 收到上一次连接中残留的数据包.
    - 假设客户端最后一次发送的ACK包在传输的时候丢失了, 由于TCP协议的超时重传机制服务端将重发FIN报文, 若客户端并没有维持TIME-WAIT状态而直接关闭的话, 当收到服务端重新发送的FIN包时,
      客户端就会用RST包来响应服务端, 这将会使得对方认为是有错误发生, 然而其实只是正常的关闭连接过程, 并没有出现异常情况.

### TIME_WAIT 状态会导致什么问题, 怎么解决

> 高并发短连接的业务场景下:
> 当服务器处理完请求后主动请求关闭连接, 服务器上会有大量的连接处于TIME_WAIT状态.
> 服务器维护每一个连接需要一个socket, 每个连接会占用一个文件描述符.
> 而文件描述符的使用是有上限的, 如果持续高并发会导致一些正常的连接失败.
>
> 解决方案: 修改配置或设置SO_REUSEADDR套接字, 使得服务器处于TIME-WAIT状态下的端口能够快速回收和重用.

### TIME-WAIT 为什么是 2MSL

> 确认服务器能否接收到客户端发出的ACK确认报文.

### 有很多 TIME-WAIT 状态如何解决

> SO_REUSEADDR套接字选项: 重用端口.
> 长连接的方式减少TCP的连接与断开.

### 有很多 CLOSE-WAIT 怎么解决

1. 检查是不是自己的代码问题.
2. 调整系统参数, 包括句柄相关参数和TCP/IP的参数, 一般一个CLOSE_WAIT会维持至少2个小时的时间, 我们可以通过调整参数来缩短这个时间.

### TCP 和 UDP 的区别

类型 | 是否面向连接 | 传输可靠性 | 传输形式 | 传输效率 | 所需资源 | 应用场景 | 首部字节 |
--- | ---------- | -------- | ------- | ------ | ------- | ------ | ------- |
TCP | 是 | 可靠 | 字节流 | 慢 | 多 | 文件传输、邮件传输 | 20~60 |
UDP | 否 | 不可靠 | 数据报文段 | 快 | 少 | 即时通讯、域名转换 | 8个字节 |

### TCP 协议中的定时器

1. 建立连接定时器: SYN超过3秒重传.
2. 重传定时器: 重传SYN超时继续重传.
3. 坚持计时器: 监控接收方的接受窗口是否变大.
4. 延迟应答计时器: 把数据和ACK一起发送给客户端, 提高效率.
5. 保活定时器(SO_KEEPLIVE): keep-alive确定对端是否还活着.
6. FIN_WAIT_2定时器: 防止客户端接受不到服务端的ACK一直在等待.
7. TIME_WAIT定时器: 确保服务端收到客户端最后一个ACK.

### TCP 是如何保证可靠性的

1. 数据分块.
2. 序列号和确认应答.
3. 校验和.
4. 流量控制(滑动窗口协议).
5. 拥塞控制.
6. ARQ协议(停止等待协议: 每发完一个分组就停止发送, 等待对方确认).
7. 超时重传.

### UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么

1. 不能保证数据能够到达目的地: 只有一个socket接收缓冲区, 没有socket发送缓冲区, 即只要有数据就发, 不管对方是否可以正确接收. socket 接收缓冲区满了之后, 新来的数据报会被丢弃.
2. 没有流量控制和重传机制.

3. connect只是把对端的IP和端口号记录下来, 高并发能提高效率, 增加系统稳定性.
4. 一定程度上提高性能: 调用bind函数, 将这个套接字指定一个端口, 不调用bind函数, 系统内核会随机分配一个端口给该套接字.

### TCP 最大连接数限制

1. client: 2^16.
2. server: 客户端IP数 × 客户端port数.
    - IPv4: 2^32 * 2^16 = 2^48 > 10w
    - IPv6: 2^128 * 2^16 = 2^144

### [TCP 流量控制与拥塞控制](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/es3oo3/)

1. 流量控制: 接收方返回的ACK中会包含自己的接收窗口大小, 以控制发送方此次发送的数据量大小.
2. 拥塞控制: 作用于网络.
    - 慢开始(由小到大的增大发送窗口, cwnd)和拥塞避免(cwnd线性增长, 让新的慢开始门限值变为发生拥塞时候的值的一半, 并将拥塞窗口置为1).
    - 快重传(接收方每收到一个失序的报文就立即发送重复确认)和快恢复.

### 快速重传机制

![快速重传机制](/NetWork/快速重传机制.png)

1. 超时重传的问题.
    - 当一个报文段丢失时, 会等待一定的超时周期然后才重传分组, 增加了端到端的时延.
    - 当一个报文段丢失时, 在其等待超时的过程中, 可能会出现这种情况:
      其后的报文段已经被接收端接收但却迟迟得不到确认, 发送端会认为也丢失了, 从而引起不必要的重传, 既浪费资源也浪费时间.

2. 累计确认机制.
    - 冗余ACK: 当接收端收到比期望序号大的报文段时, 便会重复发送最近一次确认的报文段的确认信号.
    - 快速重传: 如果在超时重传定时器溢出之前, 接收到3个(为什么是3个)重复冗余ACK, 发送端便知晓哪个报文段在传输过程中丢失了, 于是重发该报文段, 不需要等待超时重传定时器溢出.
   
### MTU MSS

### TCP 报文包含哪些信息

![TCP 报文](/NetWork/TCP报文格式.png)

1. 位码即tcp标志位:
    - SYN: 建立联机
    - ACK: 确认
    - PSH: 传送
    - FIN: 结束
    - RST: 重置
    - URG: 紧急
    - Sequence number: 序号
    - Acknowledge number: 确认号
   
2. 首部长度: 最小20字节.

### [为什么服务端易受到 SYN 攻击](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esk4h5/)

1. SYN Cache
2. SYN Cookies
3. SYN Proxy
